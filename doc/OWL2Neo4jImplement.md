## OWL2Neo4j转储实现简略说明 ##

版本：0.6

+ 核心思路：为了保证转储程序的**效率**和**可扩展性**，使用"**多线程 + 缓存**"的方式实现转储

#### 1.缓存与初始化 ####

+ 缓存的使用
  + 目的：在**内存记录**已被写入Neo4j的实体的preLabel，不需查询即可快速判断某实体是否已在库中
  + 划分：缓存又分为三大块——类、属性、实例缓存，是为了减少可能的Hash冲突
  + 实现方式：
    + 类缓存：一个线程写，三个线程读（是否需要同步？）
    + 属性缓存：一个线程写，三个线程读（是否需要同步？）
    + 实例缓存：多个线程写，多个线程读（如果没有扩容，写时还需要同步吗？还是读写都要同步？）
    + **注意**：可不可以基于**非阻塞同步机制**去实现对缓存的多线程写？（尽量的减少线程的挂起）
+ 初始化
  + 将表达了基础语义的OWL词汇作为Node写入，此后默认初始化成功，所以这部分不需载入缓存

#### 2.线程任务划分 ####

+ 类线程
  + ClassDefineThread：迭代类集，创建Node入库，同时写入label和comment，写类缓存
  + ClassConnectThread：迭代类关系，创建Relationship连接对应的Node，读类缓存


+ 属性线程
  + PropertyDefineThread：迭代属性集，创建Node入库，同时写入label和comment，写属性缓存
  + PropertyConnectThread：迭代属性关系，创建Relationship连接对应的Node，读属性缓存
+ 属性与类交互线程
  + PropertyFieldThread:指定属性定义域值域，创建Relationship连接对应Node，读类、属性缓存
+ 实例线程
  + InstanceDefineThread：**每类一个**，迭代实例集，创建Node写库，同时写入DP和label，读写实例缓存
  + InstanceConnectThread：迭代实例关系，创建Relationship连接对应的Node，读实例缓存

#### 3.线程间交互 ####

+ 交互方案设计目标
  + 在保证线程运行结果正确的前提下，尽量减少线程挂起和阻塞，让相互协作的线程能同时运行
+ 设计思路​

**结语**：

+ 目前

